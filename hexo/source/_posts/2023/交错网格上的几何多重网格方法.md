---
title: 交错网格上的几何多重网格方法
categories: []
tags: []
katex: false
comments: false
license: false
cc_license: false
abbrlink: 10990
date: 2023-06-21 16:47:15
---



<!--more-->

对于规则网格而言，未知量有多种不同的布置方式，依此可细分为顶点中心网格（vertex-centered grid）、单元中心网格（cell-centered grid）和交错网格（staggered grid）。在使用多重网格方法求解相应问题时，需要采用不同的限制算子(restriction operator)和延拓算子(prolongation(interpolation) operator)。限制算子和延拓算子统称为传递算子(transfer operator)。

对于二维顶点中心网格，限制算子使用(full weighted method)
对于二维单元中心网格，限制算子通常使用四点平均法，三维使用八点平均法。

# 线性插值算子
线性插值推广到二维、三维，可以得到双线性插值和三线性插值，它们的公式分别为：
$$
\begin{aligned}
& f(x, y, z)=\sum_{i=0}^1 \sum_{j=0}^1 \sum_{k=0}^1 f_{i, j, k} L_i(x) L_j(y) L_k(z), \\
& f(x, y, z)=\sum_{i=0}^1 \sum_{j=0}^1 f_{i, j, k} L_i(x) L_j(y),\\
& f(x, y, z)=\sum_{i=0}^1 f_{i, j, k} L_i(x).
\end{aligned}
$$
其中，$f_{i,j,k}$为函数$f(x,y,z)$在线段、矩形或长方体顶点处的值，$x,y,z$为区域内的坐标，$L_0$和$L_1$为
$$
L_0(x)=1.0-x,\\
L_1(x)=x.
$$


可通过如下C++代码来检验。

```c++
#include <array>
#include <functional>
#include <iostream>

// 考虑GPU设备运行，使用函数指针而不是lamgbda函数
double L0(double x) { return 1.0 - x; }
double L1(double x) { return x; }
double (*L[2])(double) = {L0, L1};

int test_linears()
{
    double f[2];
    // f(x) = x+1
    f[0] = 0; // (0)
    f[1] = 1; // (1)

    // std::array<std::function<double(double)>, 2> L = {{
    //     [](double x) { return (1.0-x); },
    //     [](double x) { return (x); }
    // }};

    double sum = 0.0;
    double x = 0.1;
    double y = 0.3;
    for (int i = 0; i < 2; i++)
    {
        sum += f[i] * L[i](x);
        std::cout << sum << std::endl;
    }
    return 0;
}

int test_bilinears()
{
    double f[2][2];
    // f(x,y) = x+y+2xy
    f[0][0] = 0; // (0,0)
    f[1][0] = 1; // (1,0)
    f[0][1] = 1; // (0,1)
    f[1][1] = 4; // (1,1)

    // std::array<std::function<double(double)>, 2> L = {{
    //     [](double x) { return (1.0-x); },
    //     [](double x) { return (x); }
    // }};

    double sum = 0.0;
    double x = 0.1;
    double y = 0.3;
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
        {
            sum += f[i][j] * L[i](x) * L[j](y);
            std::cout << sum << std::endl;
        }
    return 0;
}

// 三线性插值
double f_(double x, double y, double z)
{
    return x + y + z + x * y + x * z + y * z + x * y * z + 1;
}
int main()
{
    double f[2][2][2];
    // f(x,y) = x+y+z+xy+xz+yz+xyz+1
    f[0][0][0] = f_(0, 0, 0); //
    f[1][0][0] = f_(1, 0, 0); //
    f[0][1][0] = f_(0, 1, 0); //
    f[1][1][0] = f_(1, 1, 0); //
    f[0][0][1] = f_(0, 0, 1); //
    f[1][0][1] = f_(1, 0, 1); //
    f[0][1][1] = f_(0, 1, 1); //
    f[1][1][1] = f_(1, 1, 1); //

    // std::array<std::function<double(double)>, 2> L = {{
    //     [](double x) { return (1.0-x); },
    //     [](double x) { return (x); }
    // }};

    double sum = 0.0;
    double x = 0.2;
    double y = 0.3;
    double z = 0.3;
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
            for (int k = 0; k < 2; k++)
            {
                sum += f[i][j][k] * L[i](x) * L[j](y) * L[k](z);
            }

    std::cout << sum << std::endl;
    std::cout << f_(x, y, z) << std::endl;

    return 0;
}

```
